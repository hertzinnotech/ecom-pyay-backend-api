"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = __importDefault(require("path"));
var glob_1 = __importDefault(require("glob"));
var flag_router_1 = require("../../utils/flag-router");
var isTruthy = function (val) {
    if (typeof val === "string") {
        return val.toLowerCase() === "true";
    }
    return !!val;
};
exports.default = (function (configModule, logger, flagDirectory) {
    var e_1, _a;
    if (configModule === void 0) { configModule = {}; }
    var _b = configModule.featureFlags, projectConfigFlags = _b === void 0 ? {} : _b;
    var flagDir = path_1.default.join(flagDirectory || __dirname, "*.{j,t}s");
    var supportedFlags = glob_1.default.sync(flagDir, {
        ignore: ["**/index.js", "**/index.ts", "**/*.d.ts"],
    });
    var flagConfig = {};
    try {
        for (var supportedFlags_1 = __values(supportedFlags), supportedFlags_1_1 = supportedFlags_1.next(); !supportedFlags_1_1.done; supportedFlags_1_1 = supportedFlags_1.next()) {
            var flag = supportedFlags_1_1.value;
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            var importedModule = require(flag);
            if (!importedModule.default) {
                continue;
            }
            var flagSettings = importedModule.default;
            switch (true) {
                case typeof process.env[flagSettings.env_key] !== "undefined":
                    if (logger) {
                        logger.info("Using flag ".concat(flagSettings.env_key, " from environment with value ").concat(process.env[flagSettings.env_key]));
                    }
                    flagConfig[flagSettings.key] = isTruthy(process.env[flagSettings.env_key]);
                    break;
                case typeof projectConfigFlags[flagSettings.key] !== "undefined":
                    if (logger) {
                        logger.info("Using flag ".concat(flagSettings.key, " from project config with value ").concat(projectConfigFlags[flagSettings.key]));
                    }
                    flagConfig[flagSettings.key] = isTruthy(projectConfigFlags[flagSettings.key]);
                    break;
                default:
                    flagConfig[flagSettings.key] = flagSettings.default_val;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (supportedFlags_1_1 && !supportedFlags_1_1.done && (_a = supportedFlags_1.return)) _a.call(supportedFlags_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return new flag_router_1.FlagRouter(flagConfig);
});
//# sourceMappingURL=index.js.map