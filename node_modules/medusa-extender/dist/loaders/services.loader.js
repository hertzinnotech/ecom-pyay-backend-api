"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.overrideService = exports.registerService = exports.servicesLoader = void 0;
const awilix_1 = require("awilix");
const core_1 = require("../core");
const logger = core_1.Logger.contextualize('ServicesLoader');
/**
 * @internal
 * Load all custom services and overridden services into the underlying @medusajs instance.
 * @param services Any custom service that implements MedusaService
 */
async function servicesLoader(services) {
    logger.log('Loading services into the underlying @medusajs');
    let customCount = 0;
    let overriddenCount = 0;
    const serviceLoader = await Promise.resolve().then(() => require('@medusajs/medusa/dist/loaders/services'));
    const originalServiceLoader = serviceLoader.default;
    serviceLoader.default = ({ container, configModule, isTest }) => {
        originalServiceLoader({ container, configModule, isTest });
        for (const serviceOptions of services) {
            if (serviceOptions.override) {
                overrideService(container, serviceOptions, configModule);
                logger.log(`Service overridden - ${serviceOptions.metatype.name}`);
                ++overriddenCount;
            }
            else {
                registerService(container, serviceOptions, configModule);
                logger.log(`Service loaded - ${(0, core_1.lowerCaseFirst)(serviceOptions.metatype.name)}`);
                ++customCount;
            }
        }
        logger.log(`${customCount} services registered`);
        logger.log(`${overriddenCount} services overridden`);
    };
}
exports.servicesLoader = servicesLoader;
function registerService(container, serviceOptions, configModule) {
    var _a;
    const { metatype, scope } = serviceOptions;
    const resolutionKey = (_a = serviceOptions.resolutionKey) !== null && _a !== void 0 ? _a : (0, core_1.lowerCaseFirst)(metatype.name);
    container.register({
        [resolutionKey]: (0, awilix_1.asFunction)((cradle) => new metatype(cradle, configModule), { lifetime: scope || 'SINGLETON' }),
    });
}
exports.registerService = registerService;
function overrideService(container, serviceOptions, configModule) {
    const { metatype, override, scope } = serviceOptions;
    const formattedName = (0, core_1.lowerCaseFirst)(override.name);
    container.cache.delete(formattedName);
    container.register({
        [formattedName]: (0, awilix_1.asFunction)((cradle) => new metatype(cradle, configModule), {
            lifetime: scope || awilix_1.Lifetime.SINGLETON,
        }),
    });
}
exports.overrideService = overrideService;
//# sourceMappingURL=services.loader.js.map