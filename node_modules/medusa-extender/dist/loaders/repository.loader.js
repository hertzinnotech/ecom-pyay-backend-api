"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.overrideRepositoriesLoader = exports.repositoriesLoader = void 0;
const _1 = require("./");
const awilix_1 = require("awilix");
const typeorm_1 = require("typeorm");
const core_1 = require("../core");
const logger = core_1.Logger.contextualize('RepositoriesLoader');
/**
 * @internal
 * Load all custom repositories into the underlying @medusajs instance.
 * @param repositories
 * @param container
 */
async function repositoriesLoader(repositories, container) {
    logger.log('Loading custom entities into the underlying @medusajs');
    let count = 0;
    for (const repositoryOptions of repositories) {
        if (!repositoryOptions.override) {
            registerRepository(container, repositoryOptions);
            logger.log(`Repository loaded - ${(0, _1.lowerCaseFirst)(repositoryOptions.metatype.name)}`);
            ++count;
        }
    }
    logger.log(`${count} repositories registered`);
}
exports.repositoriesLoader = repositoriesLoader;
/**
 * @internal
 * Load all custom repositories that override @medusajs instance entities.
 * @param repositories
 */
async function overrideRepositoriesLoader(repositories) {
    logger.log('Loading overridden entities into the underlying @medusajs');
    let count = 0;
    for (const repositoryOptions of repositories) {
        if (repositoryOptions.override) {
            await overrideRepository(repositoryOptions);
            logger.log(`Repository overridden - ${repositoryOptions.metatype.name}`);
            ++count;
        }
    }
    logger.log(`${count} repositories overridden`);
}
exports.overrideRepositoriesLoader = overrideRepositoriesLoader;
function registerRepository(container, repositoryOptions) {
    var _a;
    const { metatype: repository } = repositoryOptions;
    const resolutionKey = (_a = repositoryOptions.resolutionKey) !== null && _a !== void 0 ? _a : `${(0, _1.lowerCaseFirst)(repository.name)}${!repository.name.toLowerCase().includes('repository') ? 'Repository' : ''}`;
    container.register({
        [resolutionKey]: (0, awilix_1.asClass)(repository),
    });
}
async function overrideRepository(repositoryOptions) {
    const { metatype, override } = repositoryOptions;
    const nameParts = override.name.split('Repository');
    const keptNameParts = nameParts.length > 1 ? nameParts.splice(nameParts.length - 2, 1) : nameParts;
    const name = keptNameParts.length > 1 ? keptNameParts.join('') : keptNameParts[0];
    const fileName = `${name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()}`;
    const originalRepository = await Promise.resolve().then(() => require('@medusajs/medusa/dist/repositories/' + fileName));
    const originalRepositoryIndex = (0, typeorm_1.getMetadataArgsStorage)().entityRepositories.findIndex((repository) => {
        return repository.target.name === override.name && repository.target !== metatype;
    });
    if (originalRepositoryIndex > -1) {
        (0, typeorm_1.getMetadataArgsStorage)().entityRepositories.splice(originalRepositoryIndex, 1);
    }
    originalRepository[override.name] = metatype;
}
//# sourceMappingURL=repository.loader.js.map