#! /usr/bin/env node
"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = require("commander");
const generate_component_1 = require("./commands/generate-component");
const chalk_1 = require("chalk");
const migrate_1 = require("./commands/migrate");
const init_1 = require("./commands/init");
const program = new commander_1.Command();
program.name('medex').description('Medusa extender CLI').version('0.8.1');
program
    .command('migrate')
    .alias('m')
    .description('Migrate all migrations found in the specified directories in the configuration')
    .option('-r, --run', 'Run migrations up method')
    .option('-u, --revert', 'Revert the last migrations')
    .option('-s, --show', 'Show all applied and non applied migrations')
    .option('-t, --tenant_codes [codes]', 'Specify on which tenant to run the command for. It can be composed of a mix of string or regexp that are comma separated (e.g "tenant1,/specialTenant.*/")')
    .action(async (options, program) => {
    console.time((0, chalk_1.green)('Migration command'));
    const { tenant_codes } = options, restOptions = __rest(options, ["tenant_codes"]);
    const optionNotValid = Object.values(restOptions).every((value) => !value);
    if (optionNotValid) {
        return program
            .showHelpAfterError(true)
            .error(`You must specify one of the options.${tenant_codes ? ' --tenant_codes only is not sufficient.' : ''}`);
    }
    if (tenant_codes && typeof tenant_codes !== 'string') {
        return program.showHelpAfterError(true).error('You must specify a value for --tenant_codes.');
    }
    await (0, migrate_1.migrate)(options);
    console.timeEnd((0, chalk_1.green)('Migration command'));
});
program
    .command('generate')
    .alias('g')
    .description('Generate a new component')
    .option('-m, --module', 'Generate a new module')
    .option('-md, --middleware', 'Generate a new middleware')
    .option('-s, --service', 'Generate a new service')
    .option('-r, --router', 'Generate a new router')
    .option('-e, --entity', 'Generate a new entity')
    .option('-re, --repository', 'Generate a new repository')
    .option('-mi, --migration', 'Generate a new migration')
    .option('-va, --validator', 'Generate a new validator')
    .option('-p, --path <path>', 'specify the path where the component must be generated (by default the component will be generated at [src/modules/<name>/<name>.<type>.ts]')
    .argument('<name>', 'specify the name of the component(s) to create')
    .action((name, options, program) => {
    console.time((0, chalk_1.green)('Generate command'));
    const { path } = options, componentOptions = __rest(options, ["path"]);
    if (Object.values(componentOptions).every((value) => !value)) {
        return program
            .showHelpAfterError(true)
            .error(`You must specify one of the options.${path ? ' --path only is not sufficient.' : ''}`);
    }
    (0, generate_component_1.generateComponent)(name, options);
    console.timeEnd((0, chalk_1.green)('Generate command'));
});
program
    .command('init')
    .alias('-i')
    .description('Update your existing medusa project to include the necessary configuration to use the medusa-extender package')
    .action(async () => {
    console.time((0, chalk_1.green)('Init command'));
    await (0, init_1.init)();
    console.timeEnd((0, chalk_1.green)('Init command'));
});
program.parse();
//# sourceMappingURL=index.js.map