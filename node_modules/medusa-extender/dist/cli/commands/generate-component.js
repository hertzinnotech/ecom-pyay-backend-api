"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateModuleImports = exports.createComponentIfNecessary = exports.generateComponent = void 0;
const parse_component_value_1 = require("../utils/parse-component-value");
const create_directory_1 = require("../utils/create-directory");
const fs_1 = require("fs");
const path_1 = require("path");
const templates_1 = require("../templates");
const core_1 = require("../../core");
const lookup_closest_module_1 = require("../utils/lookup-closest-module");
const slash_1 = require("../utils/slash");
const slashRegexp = (0, slash_1.getSlashRegexpFromPlatform)();
const logger = core_1.Logger.contextualize('Generate command', 'MEDEX-CLI');
/**
 * Generate the required components from the user command.
 * @param name
 * @param module
 * @param middleware
 * @param service
 * @param router
 * @param validator
 * @param entity
 * @param repository
 * @param migration
 * @param path
 */
function generateComponent(name, { module, middleware, service, router, validator, entity, repository, migration, path }) {
    logger.log(`Start generating component(s)`);
    const { relativeDestinationPath, fullDestinationPath } = (0, parse_component_value_1.parseComponentValue)(name, 'module', path);
    (0, create_directory_1.createDirectoryIfNecessary)(relativeDestinationPath, fullDestinationPath, logger);
    if (module) {
        const componentDescriptor = (0, parse_component_value_1.parseComponentValue)(name, 'module', path);
        createComponentIfNecessary(componentDescriptor, (0, templates_1.getModuleTemplate)(componentDescriptor.componentName));
    }
    if (middleware) {
        const componentDescriptor = (0, parse_component_value_1.parseComponentValue)(name, 'middleware', path);
        createComponentIfNecessary(componentDescriptor, (0, templates_1.getMiddlewareTemplate)(componentDescriptor.componentName));
    }
    if (service) {
        const componentDescriptor = (0, parse_component_value_1.parseComponentValue)(name, 'service', path);
        createComponentIfNecessary(componentDescriptor, (0, templates_1.getServiceTemplate)(componentDescriptor.componentName));
    }
    if (router) {
        const componentDescriptor = (0, parse_component_value_1.parseComponentValue)(name, 'router', path);
        createComponentIfNecessary(componentDescriptor, (0, templates_1.getRouterTemplate)(componentDescriptor.componentName));
    }
    if (validator) {
        const componentDescriptor = (0, parse_component_value_1.parseComponentValue)(name, 'validator', path);
        createComponentIfNecessary(componentDescriptor, (0, templates_1.getValidatorTemplate)(componentDescriptor.componentName));
    }
    if (entity) {
        const componentDescriptor = (0, parse_component_value_1.parseComponentValue)(name, 'entity', path);
        createComponentIfNecessary(componentDescriptor, (0, templates_1.getEntityTemplate)(componentDescriptor.componentName));
    }
    if (repository) {
        const componentDescriptor = (0, parse_component_value_1.parseComponentValue)(name, 'repository', path);
        createComponentIfNecessary(componentDescriptor, (0, templates_1.getRepositoryTemplate)(componentDescriptor.componentName));
    }
    if (migration) {
        const timestamp = Date.now().toString();
        const componentDescriptor = (0, parse_component_value_1.parseComponentValue)(name, 'migration', path, timestamp);
        createComponentIfNecessary(componentDescriptor, (0, templates_1.getMigrationTemplate)(componentDescriptor.componentName, timestamp));
    }
    updateModuleImports(fullDestinationPath);
    logger.warn(`!!ATTENTION!! Check the newly created component(s) to validate the config and update it if needed.`);
}
exports.generateComponent = generateComponent;
/**
 * Create the component file and fill it with the template content.
 * @param fullDestinationPath
 * @param componentName
 * @param componentFileName
 * @param content
 */
function createComponentIfNecessary({ fullDestinationPath, componentName, componentFileName, }, content) {
    const componentFullPath = (0, path_1.resolve)(fullDestinationPath, componentFileName);
    const exists = (0, fs_1.existsSync)(componentFullPath);
    if (exists) {
        logger.warn(`Component ${componentName} already exists. Skipping component creation`);
        return;
    }
    (0, fs_1.writeFileSync)(componentFullPath, content);
    logger.log(`Component ${componentFileName} successfully generated at ${fullDestinationPath}`);
}
exports.createComponentIfNecessary = createComponentIfNecessary;
/**
 * Lookup for the closest module from the component and update its imports.
 * @param fullDestinationPath
 */
function updateModuleImports(fullDestinationPath) {
    const resolvedModulePath = (0, lookup_closest_module_1.lookupClosestModule)(fullDestinationPath);
    if (!resolvedModulePath) {
        logger.warn('Unable to resolve the closest module from your component. Skipping module imports update');
        return;
    }
    const moduleFileName = resolvedModulePath.split(slashRegexp).slice(-1).pop();
    logger.log(`Updating module ${moduleFileName}`);
    const updateModuleImportsContent = (_fullDestinationPath) => {
        var _a;
        _fullDestinationPath = (0, path_1.normalize)(_fullDestinationPath);
        const components = (0, fs_1.readdirSync)(_fullDestinationPath, { withFileTypes: true });
        const files = components.filter((component) => component.isFile());
        for (const file of files) {
            if (file.name.includes('.module.'))
                continue;
            const componentFullPath = (0, path_1.resolve)(_fullDestinationPath, file.name);
            const componentContent = (0, fs_1.readFileSync)(componentFullPath).toString();
            const componentClassName = (_a = componentContent.match(/class\s(\w+)/)) === null || _a === void 0 ? void 0 : _a.pop();
            if (!componentClassName)
                continue;
            const moduleContent = (0, fs_1.readFileSync)(resolvedModulePath).toString();
            const shouldUpdateModuleImport = !moduleContent.match(`${(0, path_1.parse)(file.name).name}`);
            if (!shouldUpdateModuleImport)
                continue;
            const isComponentInSubDirectory = _fullDestinationPath.split(slashRegexp).slice(-1).pop() !==
                resolvedModulePath.split(slashRegexp).slice(-2).shift();
            const updatedModuleContent = moduleContent
                .replace(/imports: \[(.*)\]/s, (str, match) => {
                return `imports: [${match ? `${match}, ` : ''}${componentClassName}]`;
            })
                .replace(/(import\s+.*\s+from\s+.*(?!;))/, (str, matches) => {
                const subDirectoryRelativePath = isComponentInSubDirectory
                    ? _fullDestinationPath.split(slashRegexp).slice(-1).pop()
                    : null;
                return `${matches ? `${matches}\n` : ''}import { ${componentClassName} } from './${subDirectoryRelativePath ? subDirectoryRelativePath + '/' : ''}${(0, path_1.parse)(file.name).name}';`;
            });
            (0, fs_1.writeFileSync)(resolvedModulePath, updatedModuleContent);
            logger.log(`Module ${moduleFileName} imports updated from ${file.name} component`);
        }
        const directories = components.filter((component) => component.isDirectory());
        directories.forEach((directory) => updateModuleImportsContent((0, path_1.resolve)(_fullDestinationPath, directory.name)));
    };
    const resolvedModuleLocationPath = resolvedModulePath.split(slashRegexp).slice(0, -1).join('/');
    updateModuleImportsContent(resolvedModuleLocationPath);
    logger.log(`Module ${moduleFileName} updated`);
}
exports.updateModuleImports = updateModuleImports;
//# sourceMappingURL=generate-component.js.map