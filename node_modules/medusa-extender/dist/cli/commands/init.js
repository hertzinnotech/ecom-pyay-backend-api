"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.init = void 0;
const dedent = require("dedent");
const path_1 = require("path");
const core_1 = require("../../core");
const fs_1 = require("fs");
const generate_component_1 = require("./generate-component");
const templates_1 = require("../templates");
const logger = core_1.Logger.contextualize('Init command', 'MEDEX-CLI');
/**
 * Update or create everything related to medusa-extender in an existing medusa project.
 */
async function init() {
    logger.log('Initialising medusa-extender...');
    logger.log('[packages] Check that the packages are installed');
    await (0, core_1.loadPackages)(logger, [
        { name: 'typescript', version: '4.5.5', isDevDependency: true },
        { name: 'nodemon', version: '2.0.15', isDevDependency: true },
    ]);
    await updatePackageJson();
    await updateTsconfigJson();
    logger.log('[modules] Creating example module');
    (0, generate_component_1.generateComponent)('example', { module: true, service: true, router: true, path: 'src/modules/example' });
    generateEntryPoint();
    updateDevelopScript();
    logger.log('Initialisation terminated successfully. You can now run the script - npm run start');
}
exports.init = init;
/**
 * @internal
 * Update the package.json with the required scripts to work.
 */
async function updatePackageJson() {
    var _a;
    logger.log('[scripts] Update package.json scripts');
    const packageJsonPath = (0, path_1.resolve)(process.cwd(), 'package.json');
    const packageJson = await Promise.resolve().then(() => require(packageJsonPath));
    packageJson.scripts = Object.assign(Object.assign({}, ((_a = packageJson.scripts) !== null && _a !== void 0 ? _a : {})), { build: 'rm -rf dist && ./node_modules/.bin/tsc -p tsconfig.json', start: 'npm run build && NODE_ENV=development node ./dist/main.js', 'start:watch': "nodemon --watch './src/**/*.ts' --exec 'npm run build && NODE_ENV=development node ./dist/main.js'", 'start:prod': 'npm run build && NODE_ENV=production node dist/main' });
    (0, fs_1.writeFileSync)(packageJsonPath, JSON.stringify(packageJson, null, 4));
}
/**
 * @internal
 * Update or create the tsconfig.json file with the required configuration.
 */
async function updateTsconfigJson() {
    var _a, _b, _c;
    logger.log('[tsConfig] Create or update tsconfig.json');
    const tsconfigPath = (0, path_1.resolve)(process.cwd(), 'tsconfig.json');
    const isTsConfigExists = (0, fs_1.existsSync)(tsconfigPath);
    if (!isTsConfigExists) {
        logger.log('[tsconfig.json] Creating tsconfig.json');
        (0, fs_1.writeFileSync)(tsconfigPath, dedent `
            {
              "compilerOptions": {
                "module": "CommonJS",
                "declaration": true,
                "emitDecoratorMetadata": true,
                "experimentalDecorators": true,
                "allowSyntheticDefaultImports": true,
                "moduleResolution": "node",
                "target": "es2017",
                "sourceMap": true,
                "skipLibCheck": true,
                "allowJs": true,
                "outDir": "dist",
                "rootDir": "src",
                "esModuleInterop": true
              },
              "include": [
                "src"
              ],
              "exclude": [
                "dist",
                "node_modules",
                "**/*.spec.ts"
              ]
            }
        `);
    }
    else {
        logger.log('[tsconfig.json] Update tsconfig.json');
        const tsconfig = await Promise.resolve().then(() => require(tsconfigPath));
        tsconfig.compilerOptions = Object.assign(Object.assign({}, ((_a = tsconfig.compilerOptions) !== null && _a !== void 0 ? _a : {})), { module: 'CommonJS', declaration: true, emitDecoratorMetadata: true, experimentalDecorators: true, allowSyntheticDefaultImports: true, moduleResolution: 'node', target: 'es2017', sourceMap: true, skipLibCheck: true, allowJs: true, outDir: 'dist', rootDir: 'src', esModuleInterop: true });
        tsconfig.include = [...((_b = tsconfig.include) !== null && _b !== void 0 ? _b : []), 'src'];
        tsconfig.exclude = [...((_c = tsconfig.exclude) !== null && _c !== void 0 ? _c : []), 'dist', 'node_modules', '**/*.spec.ts'];
        (0, fs_1.writeFileSync)(tsconfigPath, JSON.stringify(tsconfig, null, 4));
    }
}
/**
 * @internal
 * Generate the main.ts entry point.
 */
function generateEntryPoint() {
    logger.log('[entry point] Creating entry point main.ts file');
    (0, fs_1.writeFileSync)((0, path_1.resolve)(process.cwd(), 'src', 'main.ts'), (0, templates_1.getMainEntryPointTemplate)());
}
/**
 * @internal
 * Update the existing develop shell script provided by medusa to fit the new requirements.
 */
function updateDevelopScript() {
    logger.log('[develop script] Update medusa develop.sh script');
    const developShPath = (0, path_1.resolve)(process.cwd(), 'develop.sh');
    (0, fs_1.writeFileSync)(developShPath, dedent `
		#!/bin/bash

		#Run migrations to ensure the database is updated
		medusa migrations run
		
		#Start development environment
		npm run start
	`, { mode: 777 });
}
//# sourceMappingURL=init.js.map