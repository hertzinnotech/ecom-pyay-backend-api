"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrate = void 0;
const typeorm_1 = require("typeorm");
const dist_1 = require("medusa-core-utils/dist");
const path_1 = require("path");
/**
 * Run the migrations using the medusa-config.js config.
 * @param run
 * @param revert
 * @param show
 */
async function migrate({ run, revert, show }) {
    var _a;
    const { configModule } = (0, dist_1.getConfigFile)(process.cwd(), `medusa-config`);
    const configMigrationsDirs = (_a = configModule.projectConfig.cli_migration_dirs) !== null && _a !== void 0 ? _a : configModule.projectConfig.cliMigrationsDirs;
    let uniqMigrationDirs = new Set();
    if (configMigrationsDirs === null || configMigrationsDirs === void 0 ? void 0 : configMigrationsDirs.length) {
        uniqMigrationDirs = new Set(configMigrationsDirs);
    }
    const migrationDirs = [...uniqMigrationDirs].map((dir) => {
        return (0, path_1.normalize)((0, path_1.resolve)(process.cwd(), dir));
    });
    const connection = await (0, typeorm_1.createConnection)({
        type: configModule.projectConfig.database_type,
        url: configModule.projectConfig.database_url,
        database: configModule.projectConfig.database_database,
        extra: configModule.projectConfig.database_extra || {},
        logging: ['schema'],
        migrations: migrationDirs,
    });
    if (run) {
        await connection.runMigrations();
        await connection.close();
    }
    else if (revert) {
        await connection.undoLastMigration({ transaction: 'all' });
        await connection.close();
    }
    else if (show) {
        await connection.showMigrations();
        await connection.close();
    }
}
exports.migrate = migrate;
//# sourceMappingURL=migrate.js.map