"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrate = void 0;
const typeorm_1 = require("typeorm");
const dist_1 = require("medusa-core-utils/dist");
const path_1 = require("path");
const core_1 = require("../../core");
const logger = core_1.Logger.contextualize('Migrate command', 'MEDEX-CLI');
/**
 * Run the migrations using the medusa-config.js config.
 * @param run
 * @param revert
 * @param show
 * @param tenant_codes
 */
async function migrate({ run, revert, show, tenant_codes }) {
    var _a, _b, _c, _d;
    const { configModule } = (0, dist_1.getConfigFile)(process.cwd(), `medusa-config`);
    const configMigrationsDirs = (_b = (_a = configModule === null || configModule === void 0 ? void 0 : configModule.projectConfig) === null || _a === void 0 ? void 0 : _a.cli_migration_dirs) !== null && _b !== void 0 ? _b : (_c = configModule === null || configModule === void 0 ? void 0 : configModule.projectConfig) === null || _c === void 0 ? void 0 : _c.cliMigrationsDirs;
    let uniqMigrationDirs = new Set();
    if (configMigrationsDirs === null || configMigrationsDirs === void 0 ? void 0 : configMigrationsDirs.length) {
        uniqMigrationDirs = new Set(configMigrationsDirs);
    }
    const migrationDirs = [...uniqMigrationDirs].map((dir) => {
        return (0, path_1.normalize)((0, path_1.resolve)(process.cwd(), dir));
    });
    const connections = [
        await (0, typeorm_1.createConnection)({
            type: configModule.projectConfig.database_type,
            url: configModule.projectConfig.database_url,
            database: configModule.projectConfig.database_database,
            extra: configModule.projectConfig.database_extra || {},
            logging: ['schema'],
            migrations: migrationDirs,
        }),
    ];
    if (((_d = configModule.multi_tenancy) === null || _d === void 0 ? void 0 : _d.enable) && !!tenant_codes) {
        const tenantConnections = await buildTenantsConnections(tenant_codes, migrationDirs, configModule);
        connections.push(...tenantConnections);
    }
    if (run) {
        await Promise.all(connections.map((connection) => runConnectionAction(connection, 'runMigrations', 'Run')));
    }
    else if (revert) {
        await Promise.all(connections.map((connection) => runConnectionAction(connection, 'undoLastMigration', 'Undo last')));
    }
    else if (show) {
        await Promise.all(connections.map((connection) => runConnectionAction(connection, 'showMigrations', 'Show')));
    }
    await Promise.all(connections.map((connection) => {
        return connection.close();
    }));
}
exports.migrate = migrate;
async function buildTenantsConnections(tenants, migrationDirs, configModule) {
    const connections = [];
    const tenantConfigMap = new Map();
    tenants.split(',').forEach((tenantCode) => {
        const regexp = (0, core_1.buildRegexpIfValid)(tenantCode);
        configModule.multi_tenancy.tenants.forEach((tenantConfig) => {
            if ((regexp && regexp.test(tenantConfig.code)) || tenantCode === tenantConfig.code) {
                tenantConfigMap.set(tenantConfig.code, tenantConfig.database_config);
            }
        });
    });
    for (const [tenantCode, tenantConfig] of [...tenantConfigMap]) {
        connections.push(await (0, typeorm_1.createConnection)({
            name: tenantCode,
            type: tenantConfig.database_type,
            url: tenantConfig.database_url,
            database: tenantConfig.database_database,
            extra: tenantConfig.database_extra || {},
            logging: ['schema'],
            migrations: migrationDirs,
        }));
    }
    return connections;
}
function runConnectionAction(connection, methods, action) {
    return new Promise(async (resolve, reject) => {
        await connection[methods]()
            .then(() => {
            logger.log(`${action} migrations has been applied on database connection`, connection.name);
            resolve(null);
        })
            .catch((e) => {
            reject(e);
        });
    });
}
//# sourceMappingURL=migrate.js.map