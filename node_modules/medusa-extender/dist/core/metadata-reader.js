"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.componentsMetadataReader = exports.metadataReader = void 0;
const constants_1 = require("./constants");
const componentMap_1 = require("./componentMap");
/**
 * @Internal
 *
 * Read all metadata from the imported modules and extract components that will be stored by there type.
 * @param modules The modules from which the metadata are read.
 */
function metadataReader(modules) {
    var _a;
    let componentMap = new componentMap_1.ComponentMap();
    for (const module of modules) {
        const moduleImports = Reflect.getMetadata(constants_1.MODULE_KEY, module);
        for (const component of moduleImports) {
            const subModuleImports = Reflect.getMetadata(constants_1.MODULE_KEY, component);
            if (subModuleImports) {
                const subComponentMap = metadataReader([component]);
                componentMap = new componentMap_1.ComponentMap([
                    ...Array.from(componentMap.entries()),
                    ...Array.from(subComponentMap.entries()),
                ]);
                continue;
            }
            const options = componentsMetadataReader(component);
            const metatype = component;
            componentMap.set(options.type, [...((_a = componentMap.get(options.type)) !== null && _a !== void 0 ? _a : []), Object.assign(Object.assign({}, options), { metatype })]);
        }
    }
    return componentMap;
}
exports.metadataReader = metadataReader;
/**
 * @Internal
 *
 * Return the options from components.
 * @param component
 */
function componentsMetadataReader(component) {
    return Reflect.getMetadata(constants_1.INJECTABLE_OPTIONS_KEY, component);
}
exports.componentsMetadataReader = componentsMetadataReader;
//# sourceMappingURL=metadata-reader.js.map