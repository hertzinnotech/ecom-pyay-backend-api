"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CustomEventEmmiter_listeners;
Object.defineProperty(exports, "__esModule", { value: true });
exports.customEventEmitter = void 0;
const events_1 = require("events");
const metadata_reader_1 = require("./metadata-reader");
const utils_1 = require("./utils");
/**
 * Extended event emitter to register methods that must be call when certain events are triggered and relay the handling to the API package
 */
class CustomEventEmmiter extends events_1.EventEmitter {
    constructor() {
        super();
        _CustomEventEmmiter_listeners.set(this, new Set());
    }
    /**
     * Register a new event handler.
     * @param eventName The name of the event that has to be triggered
     * @param propertyName The name of the class property that will handle the event
     * @param metatype The object that contains the property above
     */
    register(eventName, propertyName, metatype) {
        const descriptor = { eventName, propertyName, metatype };
        if (__classPrivateFieldGet(this, _CustomEventEmmiter_listeners, "f").has(descriptor)) {
            return;
        }
        __classPrivateFieldGet(this, _CustomEventEmmiter_listeners, "f").add(descriptor);
    }
    /**
     * Apply all event handlers hold by the `listenerDescriptor`.
     * @param container The IoC container that allow to resolve instance
     */
    registerListeners(container) {
        this.unregisterListeners();
        for (const listenerDescriptor of __classPrivateFieldGet(this, _CustomEventEmmiter_listeners, "f").values()) {
            const { eventName, metatype, propertyName } = listenerDescriptor;
            const serviceOptions = (0, metadata_reader_1.componentsMetadataReader)(metatype);
            const { resolutionKey } = serviceOptions;
            let metatypeInstance;
            if (resolutionKey) {
                metatypeInstance = container.resolve(resolutionKey);
            }
            else {
                const metatypeName = metatype.name;
                const formattedMetatypeName = (0, utils_1.lowerCaseFirst)(metatypeName);
                metatypeInstance = container.resolve(`${formattedMetatypeName}`);
            }
            this.on(eventName, metatypeInstance[propertyName].bind(metatypeInstance));
        }
    }
    unregisterListeners() {
        for (const listenerDescriptor of __classPrivateFieldGet(this, _CustomEventEmmiter_listeners, "f").values()) {
            const { eventName } = listenerDescriptor;
            this.removeAllListeners(eventName);
        }
    }
    /**
     * Emit an asynchrone event entity based and wait for the result.
     * @param eventName The event that must be triggered
     * @param values The data that are passed to the event handler
     */
    async emitAsync(eventName, values) {
        const eventListenerCount = this.listenerCount(eventName);
        if (!eventListenerCount) {
            return Promise.resolve(null);
        }
        return new Promise((resolve, reject) => {
            this.emit(eventName, {
                values,
                resolveOrReject: (err, res) => {
                    if (err)
                        return reject(err);
                    return resolve(res);
                },
            });
        });
    }
}
_CustomEventEmmiter_listeners = new WeakMap();
/**
 * @internal
 * Export the instance of the event emmiter.
 */
exports.customEventEmitter = new CustomEventEmmiter();
//# sourceMappingURL=event-emmiter.js.map