"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CustomEventEmitter_listeners;
Object.defineProperty(exports, "__esModule", { value: true });
exports.customEventEmitter = void 0;
const events_1 = require("events");
const metadata_reader_1 = require("./metadata-reader");
const utils_1 = require("./utils");
const EVENT_HANDLER_PROPERTY_NAME = '__medusa_extender_name__';
/**
 * Extended event emitter to register methods that must be call when certain events are triggered and relay the handling to the API package
 */
class CustomEventEmitter extends events_1.EventEmitter {
    constructor() {
        super();
        _CustomEventEmitter_listeners.set(this, new Map());
    }
    /**
     * Register a new event handler.
     * @param eventName The name of the event that has to be triggered
     * @param propertyName The name of the class property that will handle the event
     * @param metatype The object that contains the property above
     */
    register(eventName, propertyName, metatype) {
        const descriptor = { eventName, propertyName, metatype };
        const listenerDescriptors = __classPrivateFieldGet(this, _CustomEventEmitter_listeners, "f").get(descriptor.eventName) || [];
        listenerDescriptors.push(descriptor);
        __classPrivateFieldGet(this, _CustomEventEmitter_listeners, "f").set(eventName, listenerDescriptors);
    }
    /**
     * Apply all event handlers hold by the `listenerDescriptors`.
     * Only unregister and register again non singleton based event listeners.
     * No duplicate listener can exist on one handler.
     * @param container The IoC container that allow to resolve instance
     */
    registerListeners(container) {
        for (const [, listenerDescriptors] of [...__classPrivateFieldGet(this, _CustomEventEmitter_listeners, "f")]) {
            for (const listenerDescriptor of listenerDescriptors) {
                const { eventName, metatype, propertyName } = listenerDescriptor;
                const serviceOptions = (0, metadata_reader_1.componentsMetadataReader)(metatype);
                const { resolutionKey, scope } = serviceOptions;
                let metatypeInstance;
                if (resolutionKey) {
                    metatypeInstance = container.resolve(resolutionKey);
                }
                else {
                    const metatypeName = metatype.name;
                    const formattedMetatypeName = (0, utils_1.lowerCaseFirst)(metatypeName);
                    metatypeInstance = container.resolve(`${formattedMetatypeName}`);
                }
                const listenerHandler = metatypeInstance[propertyName].bind(metatypeInstance);
                const listenerHandlerName = `${eventName.toString()}${metatype.name}${propertyName}`;
                Object.defineProperty(listenerHandler, EVENT_HANDLER_PROPERTY_NAME, { value: listenerHandlerName });
                const alreadyRegisteredListenerHandlerIndex = this.rawListeners(eventName).findIndex((rawListenerHandler) => rawListenerHandler[EVENT_HANDLER_PROPERTY_NAME] === listenerHandlerName);
                if ((!scope || scope === 'SINGLETON') && alreadyRegisteredListenerHandlerIndex !== -1)
                    continue;
                if (alreadyRegisteredListenerHandlerIndex !== -1) {
                    this.removeListener(eventName, this.rawListeners(eventName)[alreadyRegisteredListenerHandlerIndex]);
                }
                this.on(eventName, listenerHandler);
            }
        }
    }
    /**
     * Emit an asynchrone event entity based and wait for the result.
     * @param eventName The event that must be triggered
     * @param values The data that are passed to the event handler
     */
    async emitAsync(eventName, values) {
        const eventListenerCount = this.listenerCount(eventName);
        if (!eventListenerCount) {
            return Promise.resolve(null);
        }
        return new Promise((resolve, reject) => {
            this.emit(eventName, {
                values,
                resolveOrReject: (err, res) => {
                    if (err)
                        return reject(err);
                    return resolve(res);
                },
            });
        });
    }
}
_CustomEventEmitter_listeners = new WeakMap();
/**
 * @internal
 * Export the instance of the event emmiter.
 */
exports.customEventEmitter = new CustomEventEmitter();
//# sourceMappingURL=event-emmiter.js.map