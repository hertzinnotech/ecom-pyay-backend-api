"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TenantService = void 0;
const decorators_1 = require("../../decorators");
const typeorm_1 = require("typeorm");
const naming_strategy_1 = require("@medusajs/medusa/dist/utils/naming-strategy");
let TenantService = class TenantService {
    constructor(_, config) {
        this.config = config;
    }
    /**
     * Provide a way to switch between database connections depending on the request property holding the tenant code.
     * @param defaultManager
     * @param req
     */
    async getOrCreateConnection(defaultManager, req) {
        var _a, _b;
        if (!((_a = this.config.multi_tenancy) === null || _a === void 0 ? void 0 : _a.tenant_code_resolver)) {
            throw new Error('Missing tenant_code_resolver from multi_tenancy config in medusa-config.');
        }
        const tenantCode = this.config.multi_tenancy.tenant_code_resolver(req);
        if (!tenantCode) {
            return defaultManager;
        }
        const tenant = this.config.multi_tenancy.tenants.find((tenantConfig) => {
            return tenantConfig.code === tenantCode;
        });
        if (!tenant) {
            throw new Error('Unable to find the tenant from the code found. Please check that the tenant code is part of the config.');
        }
        const connectionManager = (0, typeorm_1.getConnectionManager)();
        let connection;
        if (connectionManager.has(tenant.code)) {
            connection = await connectionManager.get(tenant.code);
        }
        else {
            const db_entities = req.scope.resolve('db_entities');
            await (0, typeorm_1.createConnection)({
                name: tenant.code,
                type: tenant.database_config.database_type,
                url: tenant.database_config.database_url,
                database: tenant.database_config.database_database,
                extra: tenant.database_config.database_extra || {},
                entities: db_entities,
                namingStrategy: new naming_strategy_1.ShortenedNamingStrategy(),
                logging: (_b = this.config.projectConfig.database_logging) !== null && _b !== void 0 ? _b : false,
            });
            connection = await connectionManager.get(tenant.code);
        }
        return await new Promise((resolve) => {
            connection.isConnected
                ? resolve(connection.manager)
                : connection.connect().then((conn) => resolve(conn.manager));
        });
    }
};
TenantService.resolutionKey = 'tenantService';
TenantService = __decorate([
    (0, decorators_1.Service)(),
    __metadata("design:paramtypes", [Object, Object])
], TenantService);
exports.TenantService = TenantService;
//# sourceMappingURL=tenant.service.js.map