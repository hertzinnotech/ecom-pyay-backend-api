import 'reflect-metadata';
import { Type } from '../core';
import { EntityManager, InsertEvent, RemoveEvent, UpdateEvent } from 'typeorm';
export declare type EntityEventActionOptions = {
    async: boolean;
};
export declare type EntityActions = 'Insert' | 'Update' | 'Remove';
/**
 * Event types that can be emitted.
 */
export declare type EntityEventType<Entity, TEntityActions extends EntityActions> = TEntityActions extends 'Insert' ? InsertEvent<Entity> : TEntityActions extends 'Update' ? UpdateEvent<Entity> : RemoveEvent<Entity>;
/**
 * The arguments expected by the {@link OnMedusaEntityEvent} decorator.
 */
export declare type MedusaEventEmittedParams<Entity, TEntityActions extends EntityActions> = {
    values: MedusaEventHandlerParams<Entity, TEntityActions>;
    resolveOrReject: (err?: Error, res?: unknown) => void;
};
/**
 * The arguments expected by the event handler.
 */
export declare type MedusaEventHandlerParams<Entity, TEntityActions extends EntityActions> = {
    event: EntityEventType<Entity, TEntityActions>;
    transactionalEntityManager?: EntityManager;
};
export declare class OnMedusaEntityEvent {
    #private;
    constructor(when?: string);
    static get Before(): OnMedusaEntityEvent;
    static get After(): OnMedusaEntityEvent;
    private static build;
    InsertEvent<Entity extends Type>(entity: Entity): string;
    UpdateEvent<Entity extends Type>(entity: Entity): string;
    RemoveEvent<Entity extends Type>(entity: Entity): string;
    Insert<TEntity extends Type>(entity: TEntity, options?: EntityEventActionOptions): MethodDecorator;
    Update<TEntity extends Type>(entity: TEntity, options?: EntityEventActionOptions): MethodDecorator;
    Remove<TEntity extends Type>(entity: TEntity, options?: EntityEventActionOptions): MethodDecorator;
    private buildDecorator;
}
