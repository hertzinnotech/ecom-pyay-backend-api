import { BaseService } from "medusa-interfaces";
import { Service } from 'medusa-extender';
import { EntityManager } from 'typeorm';
import { MedusaError } from "medusa-core-utils"
import { default as MedusaFulfillmentService } from "@medusajs/medusa/dist/services/fulfillment";
import { TotalsService } from "../../cart/services/totals.service";
import { LineItemService } from "../../lineItem/services/lineItem.service";
import { FulfillmentRepository } from "../repositories/fulfillment.repository";
import { TrackingLinkRepository } from "@medusajs/medusa/dist/repositories/tracking-link";
import { LineItemRepository } from "../../lineItem/repositories/lineItem.repository";
import  FulfillmentProviderService  from "@medusajs/medusa/dist/services/fulfillment-provider";
import  ShippingProfileService from "@medusajs/medusa/dist/services/shipping-profile";
import { CreateFulfillmentOrder, FulfillmentItemPartition, FulFillmentItemType } from "../types/fulfillment";
import { Fulfillment } from "../entities/fulfillment.entity";
import { LineItem } from "../../lineItem/entities/lineItem.entity";
import { ShippingMethod } from "../../shipping/entities/shippingMethod.entity";


type InjectedDependencies = {
    manager: EntityManager
    totalsService: TotalsService
    shippingProfileService: ShippingProfileService
    lineItemService: LineItemService
    fulfillmentProviderService: FulfillmentProviderService
    fulfillmentRepository: typeof FulfillmentRepository
    trackingLinkRepository: typeof TrackingLinkRepository
    lineItemRepository: typeof LineItemRepository
  }
  
@Service({override: FulfillmentService})
export class FulfillmentService extends MedusaFulfillmentService {
    static resolutionKey = 'fulfillmentService';

    private readonly manager: EntityManager;
    private readonly container: InjectedDependencies;
    private readonly fulfillmentRepository: typeof FulfillmentRepository;

    constructor(container: InjectedDependencies, private readonly config: any) {
        super(container);
        this.container = container;
        this.manager = container.manager;
        this.fulfillmentRepository = container.fulfillmentRepository;
    }

     /**
   * Creates an order fulfillment
   * If items needs to be fulfilled by different provider, we make
   * sure to partition those items, and create fulfillment for
   * those partitions.
   * @param order - order to create fulfillment for
   * @param itemsToFulfill - the items in the order to fulfill
   * @param custom - potential custom values to add
   * @return the created fulfillments
   */
  async createFulfillment(
    order: CreateFulfillmentOrder,
    itemsToFulfill: FulFillmentItemType[],
    custom: Partial<Fulfillment> = {}
  ): Promise<Fulfillment[]> {
    return await this.atomicPhase_(async (manager) => {
      const fulfillmentRepository = manager.getCustomRepository(
        this.fulfillmentRepository
      )

      const lineItems = await this.getFulfillmentItems_(order, itemsToFulfill)

      const { shipping_methods } = order

      // partition order items to their dedicated shipping method
      const fulfillments = this.partitionItems_(
        shipping_methods,
        lineItems as LineItem[]
      )

      const created = await Promise.all(
        fulfillments.map(async ({ shipping_method, items }) => {
          const ful = fulfillmentRepository.create({
            ...custom,
            provider_id: shipping_method.shipping_option.provider_id,
            items: items.map((i) => ({ item_id: i.id, quantity: i.quantity })),
            data: {},
          })

          const result = await fulfillmentRepository.save(ful)

          result.data =
            await this.container.fulfillmentProviderService.createFulfillment(
              shipping_method,
              items,
              { ...order },
              { ...result }
            )

          return fulfillmentRepository.save(result)
        })
      )

      return created
    })
  }

  /**
   * Retrieves the order line items, given an array of items.
   * @param order - the order to get line items from
   * @param items - the items to get
   * @param transformer - a function to apply to each of the items
   *    retrieved from the order, should return a line item. If the transformer
   *    returns an undefined value the line item will be filtered from the
   *    returned array.
   * @return the line items generated by the transformer.
   */
   async getFulfillmentItems_(
    order: CreateFulfillmentOrder,
    items: FulFillmentItemType[]
  ): Promise<(LineItem | null)[]> {
    const toReturn = await Promise.all(
      items.map(async ({ item_id, quantity }) => {
        const item = order.items.find((i) => i.id === item_id)
        return this.validateFulfillmentLineItem_(item, quantity)
      })
    )

    return toReturn.filter((i) => !!i)
  }

  /**
   * Checks that a given quantity of a line item can be fulfilled. Fails if the
   * fulfillable quantity is lower than the requested fulfillment quantity.
   * Fulfillable quantity is calculated by subtracting the already fulfilled
   * quantity from the quantity that was originally purchased.
   * @param item - the line item to check has sufficient fulfillable
   *   quantity.
   * @param quantity - the quantity that is requested to be fulfilled.
   * @return a line item that has the requested fulfillment quantity
   *   set.
   */
   validateFulfillmentLineItem_(
    item: LineItem | undefined,
    quantity: number
  ): LineItem | null {
    const manager = this.transactionManager_ ?? this.manager
    const lineItemRepo = manager.getCustomRepository(this.container.lineItemRepository)

    if (!item) {
      // This will in most cases be called by a webhook so to ensure that
      // things go through smoothly in instances where extra items outside
      // of Medusa are added we allow unknown items
      return null
    }

    if (quantity > item.quantity - item.fulfilled_quantity) {
      throw new MedusaError(
        MedusaError.Types.NOT_ALLOWED,
        "Cannot fulfill more items than have been purchased"
      )
    }
    return lineItemRepo.create({
      ...item,
      quantity,
    })
  }

  partitionItems_(
    shippingMethods: ShippingMethod[],
    items: LineItem[]
  ): FulfillmentItemPartition[] {
    const partitioned: FulfillmentItemPartition[] = []
    // partition order items to their dedicated shipping method
    for (const method of shippingMethods) {
      const temp: FulfillmentItemPartition = {
        shipping_method: method,
        items: [],
      }

      // for each method find the items in the order, that are associated
      // with the profile on the current shipping method
      if (shippingMethods.length === 1) {
        temp.items = items
      } else {
        const methodProfile = method.shipping_option.profile_id

        temp.items = items.filter(({ variant }) => {
          variant.product.profile_id === methodProfile
        })
      }
      partitioned.push(temp)
    }
    return partitioned
  }

}